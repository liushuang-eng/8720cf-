# 1 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/project/realtek_amebaz2_v0_example/GCC-RELEASE//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "../../../component/common/api/platform/time64.h" 1
# 17 "../../../component/common/api/platform/time64.h"
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 1 3
# 10 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/_ansi.h" 1 3
# 15 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/_ansi.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/newlib.h" 1 3
# 14 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/newlib.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/_newlib_version.h" 1 3
# 15 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/newlib.h" 2 3
# 16 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/_ansi.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/config.h" 1 3



# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 5 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/config.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/features.h" 1 3
# 6 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/config.h" 2 3
# 17 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/_ansi.h" 2 3
# 11 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/cdefs.h" 1 3
# 43 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/cdefs.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 1 3
# 41 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3

# 41 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
# 55 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef short int __int16_t;

typedef short unsigned int __uint16_t;
# 77 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef long int __int32_t;

typedef long unsigned int __uint32_t;
# 103 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;
# 134 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;
# 160 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;
# 182 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;
# 200 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;
# 214 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 44 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/cdefs.h" 2 3

# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 1 3 4
# 149 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 216 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 328 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 426 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 46 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/cdefs.h" 2 3
# 12 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 1 3
# 13 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/_ansi.h" 1 3
# 14 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 1 3 4
# 15 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 1 3
# 24 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_types.h" 1 3
# 25 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 26 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 2 3


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;



typedef long _off_t;





typedef int __pid_t;



typedef short __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;







typedef unsigned short __ino_t;
# 88 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 3
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;







typedef long _fpos_t;
# 129 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 3
typedef unsigned int __size_t;
# 145 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 3
typedef signed int _ssize_t;
# 156 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 3
typedef _ssize_t __ssize_t;


# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 1 3 4
# 357 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 160 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;



typedef unsigned long __clock_t;


typedef long __time_t;


typedef unsigned long __clockid_t;


typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef unsigned short __nlink_t;
typedef long __suseconds_t;
typedef unsigned long __useconds_t;


typedef __builtin_va_list __va_list;
# 16 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 38 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
struct _reent;

struct __locale_t;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 93 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 117 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 181 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                                          ;
  int (* _write) (struct _reent *, void *, const char *, int)

                                   ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 287 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 319 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 569 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];


  int _unspecified_locale_info;
  struct __locale_t *_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;



  struct _atexit *_atexit;
  struct _atexit _atexit0;



  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 766 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);
# 13 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 2 3



# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 1 3 4
# 17 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 2 3


# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/time.h" 1 3
# 20 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 2 3
# 28 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 1 3
# 28 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 3
typedef __uint8_t u_int8_t;


typedef __uint16_t u_int16_t;


typedef __uint32_t u_int32_t;


typedef __uint64_t u_int64_t;

typedef int register_t;
# 62 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 1 3 4
# 63 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 2 3

# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_stdint.h" 1 3
# 20 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_stdint.h" 3
typedef __int8_t int8_t ;



typedef __uint8_t uint8_t ;







typedef __int16_t int16_t ;



typedef __uint16_t uint16_t ;







typedef __int32_t int32_t ;



typedef __uint32_t uint32_t ;







typedef __int64_t int64_t ;



typedef __uint64_t uint64_t ;






typedef __intmax_t intmax_t;




typedef __uintmax_t uintmax_t;




typedef __intptr_t intptr_t;




typedef __uintptr_t uintptr_t;
# 65 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 2 3


# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/endian.h" 1 3





# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/_endian.h" 1 3
# 7 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/endian.h" 2 3
# 68 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/select.h" 1 3
# 25 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/select.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_sigset.h" 1 3
# 41 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_sigset.h" 3
typedef unsigned long __sigset_t;
# 26 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/select.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timeval.h" 1 3
# 35 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timeval.h" 3
typedef __suseconds_t suseconds_t;
# 52 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timeval.h" 3
struct timeval {
 
# 53 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timeval.h"
long long 
# 53 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timeval.h" 3
        tv_sec;
 suseconds_t tv_usec;
};
# 27 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/select.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/timespec.h" 1 3
# 38 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/timespec.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timespec.h" 1 3
# 45 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timespec.h" 3
struct timespec {
 
# 46 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timespec.h"
long long 
# 46 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_timespec.h" 3
       tv_sec;
 long tv_nsec;
};
# 39 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/timespec.h" 2 3
# 58 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/timespec.h" 3
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 28 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/select.h" 2 3



typedef __sigset_t sigset_t;
# 45 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/select.h" 3
typedef unsigned long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 71 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/select.h" 3


int select (int __n, _types_fd_set *__readfds, _types_fd_set *__writefds, _types_fd_set *__exceptfds, struct timeval *__timeout)
                                                   ;

int pselect (int __n, _types_fd_set *__readfds, _types_fd_set *__writefds, _types_fd_set *__exceptfds, const struct timespec *__timeout, const sigset_t *__set)

                           ;



# 69 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 2 3




typedef __uint32_t in_addr_t;




typedef __uint16_t in_port_t;
# 87 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 3
typedef unsigned char u_char;



typedef unsigned short u_short;



typedef unsigned int u_int;



typedef unsigned long u_long;







typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;



typedef __blkcnt_t blkcnt_t;




typedef __blksize_t blksize_t;




typedef unsigned long clock_t;
# 135 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 3
typedef long daddr_t;



typedef char * caddr_t;




typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;




typedef __id_t id_t;




typedef __ino_t ino_t;
# 173 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 3
typedef __off_t off_t;



typedef __dev_t dev_t;



typedef __uid_t uid_t;



typedef __gid_t gid_t;




typedef __pid_t pid_t;




typedef __key_t key_t;




typedef _ssize_t ssize_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __clockid_t clockid_t;





typedef __timer_t timer_t;





typedef __useconds_t useconds_t;
# 236 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 3
typedef __int64_t sbintime_t;


# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_pthreadtypes.h" 1 3
# 240 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/machine/types.h" 1 3
# 241 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/types.h" 2 3
# 29 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 2 3



# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_locale.h" 1 3
# 9 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/_locale.h" 3
struct __locale_t;
typedef struct __locale_t *locale_t;
# 33 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 2 3




struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;






};

clock_t clock (void);
double difftime (
# 57 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
         long long 
# 57 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
         _time2, 
# 57 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
         long long 
# 57 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
         _time1);

# 58 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
long long 
# 58 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
         mktime (struct tm *_timeptr);

# 59 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
long long 
# 59 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
         time (
# 59 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
         long long 
# 59 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
         *_timer);

char *asctime (const struct tm *_tblock);
char *ctime (const 
# 62 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
       long long 
# 62 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
       *_time);
struct tm *gmtime (const 
# 63 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
          long long 
# 63 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
          *_timer);
struct tm *localtime (const 
# 64 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
          long long 
# 64 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
          *_timer);

size_t strftime (char *restrict _s, size_t _maxsize, const char *restrict _fmt, const struct tm *restrict _t)

                                        ;


extern size_t strftime_l (char *restrict _s, size_t _maxsize,
     const char *restrict _fmt,
     const struct tm *restrict _t, locale_t _l);


char *asctime_r (const struct tm *restrict, char *restrict)
                       ;
char *ctime_r (const 
# 78 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
       long long 
# 78 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
       *, char *);
struct tm *gmtime_r (const 
# 79 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
          long long 
# 79 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
          *restrict, struct tm *restrict)
                            ;
struct tm *localtime_r (const 
# 81 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
          long long 
# 81 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
          *restrict, struct tm *restrict)
                            ;


# 101 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
void tzset (void);

void _tzset_r (struct _reent *);

typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  
# 112 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h"
 long long 
# 112 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
        change;
  long offset;
} __tzrule_type;

typedef struct __tzinfo_struct
{
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo (void);
# 154 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/time.h" 3
extern long _timezone;
extern int _daylight;


extern char *_tzname[2];
# 18 "../../../component/common/api/platform/time64.h" 2
# 1 "<command-line>" 2
# 1 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
# 118 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
# 1 "../../../component/common/file_system/fatfs/r0.10c/include/ff.h" 1
# 24 "../../../component/common/file_system/fatfs/r0.10c/include/ff.h"
# 1 "../../../component/common/file_system/fatfs/r0.10c/include/integer.h" 1
# 16 "../../../component/common/file_system/fatfs/r0.10c/include/integer.h"

# 16 "../../../component/common/file_system/fatfs/r0.10c/include/integer.h"
typedef unsigned char BYTE;


typedef short SHORT;
typedef unsigned short WORD;
typedef unsigned short WCHAR;


typedef int INT;

typedef unsigned int UINT;


typedef long LONG;
typedef unsigned long DWORD;
# 25 "../../../component/common/file_system/fatfs/r0.10c/include/ff.h" 2
# 1 "../../../component/common/file_system/fatfs/r0.10c/include/ffconf.h" 1
# 26 "../../../component/common/file_system/fatfs/r0.10c/include/ff.h" 2
# 70 "../../../component/common/file_system/fatfs/r0.10c/include/ff.h"
typedef char TCHAR;
# 81 "../../../component/common/file_system/fatfs/r0.10c/include/ff.h"
typedef struct {
 BYTE fs_type;
 BYTE drv;
 BYTE csize;
 BYTE n_fats;
 BYTE wflag;
 BYTE fsi_flag;
 WORD id;
 WORD n_rootdir;







 DWORD last_clust;
 DWORD free_clust;




 DWORD n_fatent;
 DWORD fsize;
 DWORD volbase;
 DWORD fatbase;
 DWORD dirbase;
 DWORD database;
 DWORD winsect;



 BYTE win[512];

} FATFS;





typedef struct {
 FATFS* fs;
 WORD id;
 BYTE flag;
 BYTE err;
 DWORD fptr;
 DWORD fsize;
 DWORD sclust;
 DWORD clust;
 DWORD dsect;

 DWORD dir_sect;
 BYTE* dir_ptr;
# 145 "../../../component/common/file_system/fatfs/r0.10c/include/ff.h"
  BYTE buf[512];


} FIL;





typedef struct {
 FATFS* fs;
 WORD id;
 WORD index;
 DWORD sclust;
 DWORD clust;
 DWORD sect;
 BYTE* dir;
 BYTE* fn;




 WCHAR* lfn;
 WORD lfn_idx;

} DIR;





typedef struct {
 DWORD fsize;
 WORD fdate;
 WORD ftime;
 BYTE fattrib;
 TCHAR fname[13];

 TCHAR* lfname;
 UINT lfsize;

} FILINFO;





typedef enum {
 FR_OK = 0,
 FR_DISK_ERR,
 FR_INT_ERR,
 FR_NOT_READY,
 FR_NO_FILE,
 FR_NO_PATH,
 FR_INVALID_NAME,
 FR_DENIED,
 FR_EXIST,
 FR_INVALID_OBJECT,
 FR_WRITE_PROTECTED,
 FR_INVALID_DRIVE,
 FR_NOT_ENABLED,
 FR_NO_FILESYSTEM,
 FR_MKFS_ABORTED,
 FR_TIMEOUT,
 FR_LOCKED,
 FR_NOT_ENOUGH_CORE,
 FR_TOO_MANY_OPEN_FILES,
 FR_INVALID_PARAMETER
} FRESULT;






FRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);
FRESULT f_close (FIL* fp);
FRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);
FRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);
FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);
FRESULT f_lseek (FIL* fp, DWORD ofs);
FRESULT f_truncate (FIL* fp);
FRESULT f_sync (FIL* fp);
FRESULT f_opendir (DIR* dp, const TCHAR* path);
FRESULT f_closedir (DIR* dp);
FRESULT f_readdir (DIR* dp, FILINFO* fno);
FRESULT f_mkdir (const TCHAR* path);
FRESULT f_unlink (const TCHAR* path);
FRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);
FRESULT f_stat (const TCHAR* path, FILINFO* fno);
FRESULT f_chmod (const TCHAR* path, BYTE value, BYTE mask);
FRESULT f_utime (const TCHAR* path, const FILINFO* fno);
FRESULT f_chdir (const TCHAR* path);
FRESULT f_chdrive (const TCHAR* path);
FRESULT f_getcwd (TCHAR* buff, UINT len);
FRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);
FRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);
FRESULT f_setlabel (const TCHAR* label);
FRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);
FRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);
FRESULT f_fdisk (BYTE pdrv, const DWORD szt[], void* work);
int f_putc (TCHAR c, FIL* fp);
int f_puts (const TCHAR* str, FIL* cp);
int f_printf (FIL* fp, const TCHAR* str, ...);
TCHAR* f_gets (TCHAR* buff, int len, FIL* fp);
# 268 "../../../component/common/file_system/fatfs/r0.10c/include/ff.h"
DWORD get_fattime (void);




WCHAR ff_convert (WCHAR chr, UINT dir);
WCHAR ff_wtoupper (WCHAR chr);
# 119 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c" 2
# 1 "../../../component/common/file_system/fatfs/r0.10c/include/diskio.h" 1
# 19 "../../../component/common/file_system/fatfs/r0.10c/include/diskio.h"
typedef BYTE DSTATUS;


typedef enum {
 RES_OK = 0,
 RES_ERROR,
 RES_WRPRT,
 RES_NOTRDY,
 RES_PARERR
} DRESULT;






DSTATUS disk_initialize (BYTE pdrv);
DSTATUS disk_deinitialize (BYTE pdrv);
DSTATUS disk_status (BYTE pdrv);
DRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);
DRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);
DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
# 120 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c" 2
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/string.h" 1 3
# 17 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/string.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/lib/gcc/arm-none-eabi/6.5.0/include/stddef.h" 1 3 4
# 18 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/string.h" 2 3








# 25 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/string.h" 3
void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void * restrict, const void * restrict, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *restrict, const char *restrict);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *restrict, const char *restrict);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *restrict, const char *restrict, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *restrict, const char *restrict, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);

char *strtok (char *restrict, const char *restrict);

size_t strxfrm (char *restrict, const char *restrict, size_t);


int strcoll_l (const char *, const char *, locale_t);
char *strerror_l (int, locale_t);
size_t strxfrm_l (char *restrict, const char *restrict, size_t, locale_t);






char *strtok_r (char *restrict, const char *restrict, char **restrict);


int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);


void explicit_bzero (void *, size_t);
int timingsafe_bcmp (const void *, const void *, size_t);
int timingsafe_memcmp (const void *, const void *, size_t);


int ffs (int);
char *index (const char *, int);


void * memccpy (void * restrict, const void * restrict, int, size_t);
# 86 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/string.h" 3
char *rindex (const char *, int);


char *stpcpy (char *restrict, const char *restrict);
char *stpncpy (char *restrict, const char *restrict, size_t);


int strcasecmp (const char *, const char *);






char *strdup (const char *);

char *_strdup_r (struct _reent *, const char *);

char *strndup (const char *, size_t);

char *_strndup_r (struct _reent *, const char *, size_t);
# 121 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/string.h" 3
int strerror_r (int, char *, size_t)

             __asm__ ("" "__xpg_strerror_r")

  ;







char * _strerror_r (struct _reent *, int, int, int *);


size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);


int strncasecmp (const char *, const char *, size_t);


size_t strnlen (const char *, size_t);


char *strsep (char **, const char *);



char *strlwr (char *);
char *strupr (char *);



char *strsignal (int __signo);
# 192 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/string.h" 3
# 1 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/sys/string.h" 1 3
# 193 "/home/ls/samba_share/sdk-ameba-v7.1d/tools/arm-none-eabi-gcc/asdk/linux/newlib/arm-none-eabi/include/string.h" 2 3


# 121 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c" 2
# 490 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"

# 490 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FATFS *FatFs[1];




static
WORD Fsid;
# 515 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
WCHAR LfnBuf[255 +1];
# 539 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
const BYTE ExCvt[] = {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF};
# 603 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
int chk_chr (const char* str, int chr) {
 while (*str && *str != chr) str++;
 return *str;
}
# 759 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT sync_window (
 FATFS* fs
)
{
 DWORD wsect;
 UINT nf;


 if (fs->wflag) {
  wsect = fs->winsect;
  if (disk_write(fs->drv, fs->win, wsect, 1))
   return FR_DISK_ERR;
  fs->wflag = 0;
  if (wsect - fs->fatbase < fs->fsize) {
   for (nf = fs->n_fats; nf >= 2; nf--) {
    wsect += fs->fsize;
    disk_write(fs->drv, fs->win, wsect, 1);
   }
  }
 }
 return FR_OK;
}



static
FRESULT move_window (
 FATFS* fs,
 DWORD sector
)
{
 if (sector != fs->winsect) {

  if (sync_window(fs) != FR_OK)
   return FR_DISK_ERR;

  if (disk_read(fs->drv, fs->win, sector, 1))
   return FR_DISK_ERR;
  fs->winsect = sector;
 }

 return FR_OK;
}
# 811 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT sync_fs (
 FATFS* fs
)
{
 FRESULT res;


 res = sync_window(fs);
 if (res == FR_OK) {

  if (fs->fs_type == 3 && fs->fsi_flag == 1) {

   memset(fs->win, 0, ((UINT)512));
   *(BYTE*)(fs->win+510)=(BYTE)(0xAA55); *((BYTE*)(fs->win+510)+1)=(BYTE)((WORD)(0xAA55)>>8);
   *(BYTE*)(fs->win+0)=(BYTE)(0x41615252); *((BYTE*)(fs->win+0)+1)=(BYTE)((WORD)(0x41615252)>>8); *((BYTE*)(fs->win+0)+2)=(BYTE)((DWORD)(0x41615252)>>16); *((BYTE*)(fs->win+0)+3)=(BYTE)((DWORD)(0x41615252)>>24);
   *(BYTE*)(fs->win+484)=(BYTE)(0x61417272); *((BYTE*)(fs->win+484)+1)=(BYTE)((WORD)(0x61417272)>>8); *((BYTE*)(fs->win+484)+2)=(BYTE)((DWORD)(0x61417272)>>16); *((BYTE*)(fs->win+484)+3)=(BYTE)((DWORD)(0x61417272)>>24);
   *(BYTE*)(fs->win+488)=(BYTE)(fs->free_clust); *((BYTE*)(fs->win+488)+1)=(BYTE)((WORD)(fs->free_clust)>>8); *((BYTE*)(fs->win+488)+2)=(BYTE)((DWORD)(fs->free_clust)>>16); *((BYTE*)(fs->win+488)+3)=(BYTE)((DWORD)(fs->free_clust)>>24);
   *(BYTE*)(fs->win+492)=(BYTE)(fs->last_clust); *((BYTE*)(fs->win+492)+1)=(BYTE)((WORD)(fs->last_clust)>>8); *((BYTE*)(fs->win+492)+2)=(BYTE)((DWORD)(fs->last_clust)>>16); *((BYTE*)(fs->win+492)+3)=(BYTE)((DWORD)(fs->last_clust)>>24);

   fs->winsect = fs->volbase + 1;
   disk_write(fs->drv, fs->win, fs->winsect, 1);
   fs->fsi_flag = 0;
  }

  if (disk_ioctl(fs->drv, 0, 0) != RES_OK)
   res = FR_DISK_ERR;
 }

 return res;
}
# 852 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
DWORD clust2sect (
 FATFS* fs,
 DWORD clst
)
{
 clst -= 2;
 if (clst >= (fs->n_fatent - 2)) return 0;
 return clst * fs->csize + fs->database;
}
# 870 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
DWORD get_fat (
 FATFS* fs,
 DWORD clst
)
{
 UINT wc, bc;
 BYTE *p;


 if (clst < 2 || clst >= fs->n_fatent)
  return 1;

 switch (fs->fs_type) {
 case 1 :
  bc = (UINT)clst; bc += bc / 2;
  if (move_window(fs, fs->fatbase + (bc / ((UINT)512)))) break;
  wc = fs->win[bc % ((UINT)512)]; bc++;
  if (move_window(fs, fs->fatbase + (bc / ((UINT)512)))) break;
  wc |= fs->win[bc % ((UINT)512)] << 8;
  return clst & 1 ? wc >> 4 : (wc & 0xFFF);

 case 2 :
  if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2)))) break;
  p = &fs->win[clst * 2 % ((UINT)512)];
  return (WORD)(((WORD)*((BYTE*)(p)+1)<<8)|(WORD)*(BYTE*)(p));

 case 3 :
  if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4)))) break;
  p = &fs->win[clst * 4 % ((UINT)512)];
  return (DWORD)(((DWORD)*((BYTE*)(p)+3)<<24)|((DWORD)*((BYTE*)(p)+2)<<16)|((WORD)*((BYTE*)(p)+1)<<8)|*(BYTE*)(p)) & 0x0FFFFFFF;

 default:
  return 1;
 }

 return 0xFFFFFFFF;
}
# 916 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT put_fat (
 FATFS* fs,
 DWORD clst,
 DWORD val
)
{
 UINT bc;
 BYTE *p;
 FRESULT res;


 if (clst < 2 || clst >= fs->n_fatent) {
  res = FR_INT_ERR;

 } else {
  switch (fs->fs_type) {
  case 1 :
   bc = (UINT)clst; bc += bc / 2;
   res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
   if (res != FR_OK) break;
   p = &fs->win[bc % ((UINT)512)];
   *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   bc++;
   fs->wflag = 1;
   res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
   if (res != FR_OK) break;
   p = &fs->win[bc % ((UINT)512)];
   *p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   break;

  case 2 :
   res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2)));
   if (res != FR_OK) break;
   p = &fs->win[clst * 2 % ((UINT)512)];
   *(BYTE*)(p)=(BYTE)((WORD)val); *((BYTE*)(p)+1)=(BYTE)((WORD)((WORD)val)>>8);
   break;

  case 3 :
   res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4)));
   if (res != FR_OK) break;
   p = &fs->win[clst * 4 % ((UINT)512)];
   val |= (DWORD)(((DWORD)*((BYTE*)(p)+3)<<24)|((DWORD)*((BYTE*)(p)+2)<<16)|((WORD)*((BYTE*)(p)+1)<<8)|*(BYTE*)(p)) & 0xF0000000;
   *(BYTE*)(p)=(BYTE)(val); *((BYTE*)(p)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(p)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(p)+3)=(BYTE)((DWORD)(val)>>24);
   break;

  default :
   res = FR_INT_ERR;
  }
  fs->wflag = 1;
 }

 return res;
}
# 978 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT remove_chain (
 FATFS* fs,
 DWORD clst
)
{
 FRESULT res;
 DWORD nxt;




 if (clst < 2 || clst >= fs->n_fatent) {
  res = FR_INT_ERR;

 } else {
  res = FR_OK;
  while (clst < fs->n_fatent) {
   nxt = get_fat(fs, clst);
   if (nxt == 0) break;
   if (nxt == 1) { res = FR_INT_ERR; break; }
   if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   res = put_fat(fs, clst, 0);
   if (res != FR_OK) break;
   if (fs->free_clust != 0xFFFFFFFF) {
    fs->free_clust++;
    fs->fsi_flag |= 1;
   }
# 1016 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
   clst = nxt;
  }
 }

 return res;
}
# 1031 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
DWORD create_chain (
 FATFS* fs,
 DWORD clst
)
{
 DWORD cs, ncl, scl;
 FRESULT res;


 if (clst == 0) {
  scl = fs->last_clust;
  if (!scl || scl >= fs->n_fatent) scl = 1;
 }
 else {
  cs = get_fat(fs, clst);
  if (cs < 2) return 1;
  if (cs == 0xFFFFFFFF) return cs;
  if (cs < fs->n_fatent) return cs;
  scl = clst;
 }

 ncl = scl;
 for (;;) {
  ncl++;
  if (ncl >= fs->n_fatent) {
   ncl = 2;
   if (ncl > scl) return 0;
  }
  cs = get_fat(fs, ncl);
  if (cs == 0) break;
  if (cs == 0xFFFFFFFF || cs == 1)
   return cs;
  if (ncl == scl) return 0;
 }

 res = put_fat(fs, ncl, 0x0FFFFFFF);
 if (res == FR_OK && clst != 0) {
  res = put_fat(fs, clst, ncl);
 }
 if (res == FR_OK) {
  fs->last_clust = ncl;
  if (fs->free_clust != 0xFFFFFFFF) {
   fs->free_clust--;
   fs->fsi_flag |= 1;
  }
 } else {
  ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 }

 return ncl;
}
# 1121 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT dir_sdi (
 DIR* dp,
 UINT idx
)
{
 DWORD clst, sect;
 UINT ic;


 dp->index = (WORD)idx;
 clst = dp->sclust;
 if (clst == 1 || clst >= dp->fs->n_fatent)
  return FR_INT_ERR;
 if (!clst && dp->fs->fs_type == 3)
  clst = dp->fs->dirbase;

 if (clst == 0) {
  if (idx >= dp->fs->n_rootdir)
   return FR_INT_ERR;
  sect = dp->fs->dirbase;
 }
 else {
  ic = ((UINT)512) / 32 * dp->fs->csize;
  while (idx >= ic) {
   clst = get_fat(dp->fs, clst);
   if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   if (clst < 2 || clst >= dp->fs->n_fatent)
    return FR_INT_ERR;
   idx -= ic;
  }
  sect = clust2sect(dp->fs, clst);
 }
 dp->clust = clst;
 if (!sect) return FR_INT_ERR;
 dp->sect = sect + idx / (((UINT)512) / 32);
 dp->dir = dp->fs->win + (idx % (((UINT)512) / 32)) * 32;

 return FR_OK;
}
# 1169 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT dir_next (
 DIR* dp,
 int stretch
)
{
 DWORD clst;
 UINT i;


 i = dp->index + 1;
 if (!(i & 0xFFFF) || !dp->sect)
  return FR_NO_FILE;

 if (!(i % (((UINT)512) / 32))) {
  dp->sect++;

  if (!dp->clust) {
   if (i >= dp->fs->n_rootdir)
    return FR_NO_FILE;
  }
  else {
   if (((i / (((UINT)512) / 32)) & (dp->fs->csize - 1)) == 0) {
    clst = get_fat(dp->fs, dp->clust);
    if (clst <= 1) return FR_INT_ERR;
    if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    if (clst >= dp->fs->n_fatent) {

     UINT c;
     if (!stretch) return FR_NO_FILE;
     clst = create_chain(dp->fs, dp->clust);
     if (clst == 0) return FR_DENIED;
     if (clst == 1) return FR_INT_ERR;
     if (clst == 0xFFFFFFFF) return FR_DISK_ERR;

     if (sync_window(dp->fs)) return FR_DISK_ERR;
     memset(dp->fs->win, 0, ((UINT)512));
     dp->fs->winsect = clust2sect(dp->fs, clst);
     for (c = 0; c < dp->fs->csize; c++) {
      dp->fs->wflag = 1;
      if (sync_window(dp->fs)) return FR_DISK_ERR;
      dp->fs->winsect++;
     }
     dp->fs->winsect -= c;




    }
    dp->clust = clst;
    dp->sect = clust2sect(dp->fs, clst);
   }
  }
 }

 dp->index = (WORD)i;
 dp->dir = dp->fs->win + (i % (((UINT)512) / 32)) * 32;

 return FR_OK;
}
# 1238 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT dir_alloc (
 DIR* dp,
 UINT nent
)
{
 FRESULT res;
 UINT n;


 res = dir_sdi(dp, 0);
 if (res == FR_OK) {
  n = 0;
  do {
   res = move_window(dp->fs, dp->sect);
   if (res != FR_OK) break;
   if (dp->dir[0] == 0xE5 || dp->dir[0] == 0) {
    if (++n == nent) break;
   } else {
    n = 0;
   }
   res = dir_next(dp, 1);
  } while (res == FR_OK);
 }
 if (res == FR_NO_FILE) res = FR_DENIED;
 return res;
}
# 1274 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
DWORD ld_clust (
 FATFS* fs,
 BYTE* dir
)
{
 DWORD cl;

 cl = (WORD)(((WORD)*((BYTE*)(dir+26)+1)<<8)|(WORD)*(BYTE*)(dir+26));
 if (fs->fs_type == 3)
  cl |= (DWORD)(WORD)(((WORD)*((BYTE*)(dir+20)+1)<<8)|(WORD)*(BYTE*)(dir+20)) << 16;

 return cl;
}



static
void st_clust (
 BYTE* dir,
 DWORD cl
)
{
 *(BYTE*)(dir+26)=(BYTE)(cl); *((BYTE*)(dir+26)+1)=(BYTE)((WORD)(cl)>>8);
 *(BYTE*)(dir+20)=(BYTE)(cl >> 16); *((BYTE*)(dir+20)+1)=(BYTE)((WORD)(cl >> 16)>>8);
}
# 1309 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};


static
int cmp_lfn (
 WCHAR* lfnbuf,
 BYTE* dir
)
{
 UINT i, s;
 WCHAR wc, uc;


 i = ((dir[0] & ~0x40) - 1) * 13;
 s = 0; wc = 1;
 do {
  uc = (WORD)(((WORD)*((BYTE*)(dir+LfnOfs[s])+1)<<8)|(WORD)*(BYTE*)(dir+LfnOfs[s]));
  if (wc) {
   wc = ff_wtoupper(uc);
   if (i >= 255 || wc != ff_wtoupper(lfnbuf[i++]))
    return 0;
  } else {
   if (uc != 0xFFFF) return 0;
  }
 } while (++s < 13);

 if ((dir[0] & 0x40) && wc && lfnbuf[i])
  return 0;

 return 1;
}



static
int pick_lfn (
 WCHAR* lfnbuf,
 BYTE* dir
)
{
 UINT i, s;
 WCHAR wc, uc;


 i = ((dir[0] & 0x3F) - 1) * 13;

 s = 0; wc = 1;
 do {
  uc = (WORD)(((WORD)*((BYTE*)(dir+LfnOfs[s])+1)<<8)|(WORD)*(BYTE*)(dir+LfnOfs[s]));
  if (wc) {
   if (i >= 255) return 0;
   lfnbuf[i++] = wc = uc;
  } else {
   if (uc != 0xFFFF) return 0;
  }
 } while (++s < 13);

 if (dir[0] & 0x40) {
  if (i >= 255) return 0;
  lfnbuf[i] = 0;
 }

 return 1;
}



static
void fit_lfn (
 const WCHAR* lfnbuf,
 BYTE* dir,
 BYTE ord,
 BYTE sum
)
{
 UINT i, s;
 WCHAR wc;


 dir[13] = sum;
 dir[11] = 0x0F;
 dir[12] = 0;
 *(BYTE*)(dir+26)=(BYTE)(0); *((BYTE*)(dir+26)+1)=(BYTE)((WORD)(0)>>8);

 i = (ord - 1) * 13;
 s = wc = 0;
 do {
  if (wc != 0xFFFF) wc = lfnbuf[i++];
  *(BYTE*)(dir+LfnOfs[s])=(BYTE)(wc); *((BYTE*)(dir+LfnOfs[s])+1)=(BYTE)((WORD)(wc)>>8);
  if (!wc) wc = 0xFFFF;
 } while (++s < 13);
 if (wc == 0xFFFF || !lfnbuf[i]) ord |= 0x40;
 dir[0] = ord;
}
# 1415 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
void gen_numname (
 BYTE* dst,
 const BYTE* src,
 const WCHAR* lfn,
 UINT seq
)
{
 BYTE ns[8], c;
 UINT i, j;


 memcpy(dst, src, 11);

 if (seq > 5) {
  WCHAR wc;
  DWORD sr = seq;

  while (*lfn) {
   wc = *lfn++;
   for (i = 0; i < 16; i++) {
    sr = (sr << 1) + (wc & 1);
    wc >>= 1;
    if (sr & 0x10000) sr ^= 0x11021;
   }
  }
  seq = (UINT)sr;
 }


 i = 7;
 do {
  c = (seq % 16) + '0';
  if (c > '9') c += 7;
  ns[i--] = c;
  seq /= 16;
 } while (seq);
 ns[i] = '~';


 for (j = 0; j < i && dst[j] != ' '; j++) {
  if (0) {
   if (j == i - 1) break;
   j++;
  }
 }
 do {
  dst[j++] = (i < 8) ? ns[i++] : ' ';
 } while (j < 8);
}
# 1474 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
BYTE sum_sfn (
 const BYTE* dir
)
{
 BYTE sum = 0;
 UINT n = 11;

 do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 return sum;
}
# 1494 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT dir_find (
 DIR* dp
)
{
 FRESULT res;
 BYTE c, *dir;

 BYTE a, ord, sum;


 res = dir_sdi(dp, 0);
 if (res != FR_OK) return res;


 ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;

 do {
  res = move_window(dp->fs, dp->sect);
  if (res != FR_OK) break;
  dir = dp->dir;
  c = dir[0];
  if (c == 0) { res = FR_NO_FILE; break; }

  a = dir[11] & 0x3F;
  if (c == 0xE5 || ((a & 0x08) && a != 0x0F)) {
   ord = 0xFF; dp->lfn_idx = 0xFFFF;
  } else {
   if (a == 0x0F) {
    if (dp->lfn) {
     if (c & 0x40) {
      sum = dir[13];
      c &= ~0x40; ord = c;
      dp->lfn_idx = dp->index;
     }

     ord = (c == ord && sum == dir[13] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
    }
   } else {
    if (!ord && sum == sum_sfn(dir)) break;
    if (!(dp->fn[11] & 0x01) && !memcmp(dir, dp->fn, 11)) break;
    ord = 0xFF; dp->lfn_idx = 0xFFFF;
   }
  }




  res = dir_next(dp, 0);
 } while (res == FR_OK);

 return res;
}
# 1555 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT dir_read (
 DIR* dp,
 int vol
)
{
 FRESULT res;
 BYTE a, c, *dir;

 BYTE ord = 0xFF, sum = 0xFF;


 res = FR_NO_FILE;
 while (dp->sect) {
  res = move_window(dp->fs, dp->sect);
  if (res != FR_OK) break;
  dir = dp->dir;
  c = dir[0];
  if (c == 0) { res = FR_NO_FILE; break; }
  a = dir[11] & 0x3F;

  if (c == 0xE5 || (!0 && c == '.') || (int)(a == 0x08) != vol) {
   ord = 0xFF;
  } else {
   if (a == 0x0F) {
    if (c & 0x40) {
     sum = dir[13];
     c &= ~0x40; ord = c;
     dp->lfn_idx = dp->index;
    }

    ord = (c == ord && sum == dir[13] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   } else {
    if (ord || sum != sum_sfn(dir))
     dp->lfn_idx = 0xFFFF;
    break;
   }
  }




  res = dir_next(dp, 0);
  if (res != FR_OK) break;
 }

 if (res != FR_OK) dp->sect = 0;

 return res;
}
# 1614 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT dir_register (
 DIR* dp
)
{
 FRESULT res;

 UINT n, nent;
 BYTE sn[12], *fn, sum;
 WCHAR *lfn;


 fn = dp->fn; lfn = dp->lfn;
 memcpy(sn, fn, 12);

 if (0 && (sn[11] & 0x20))
  return FR_INVALID_NAME;

 if (sn[11] & 0x01) {
  fn[11] = 0; dp->lfn = 0;
  for (n = 1; n < 100; n++) {
   gen_numname(fn, sn, lfn, n);
   res = dir_find(dp);
   if (res != FR_OK) break;
  }
  if (n == 100) return FR_DENIED;
  if (res != FR_NO_FILE) return res;
  fn[11] = sn[11]; dp->lfn = lfn;
 }

 if (sn[11] & 0x02) {
  for (n = 0; lfn[n]; n++) ;
  nent = (n + 25) / 13;
 } else {
  nent = 1;
 }
 res = dir_alloc(dp, nent);

 if (res == FR_OK && --nent) {
  res = dir_sdi(dp, dp->index - nent);
  if (res == FR_OK) {
   sum = sum_sfn(dp->fn);
   do {
    res = move_window(dp->fs, dp->sect);
    if (res != FR_OK) break;
    fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
    dp->fs->wflag = 1;
    res = dir_next(dp, 0);
   } while (res == FR_OK && --nent);
  }
 }




 if (res == FR_OK) {
  res = move_window(dp->fs, dp->sect);
  if (res == FR_OK) {
   memset(dp->dir, 0, 32);
   memcpy(dp->dir, dp->fn, 11);

   dp->dir[12] = dp->fn[11] & (0x08 | 0x10);

   dp->fs->wflag = 1;
  }
 }

 return res;
}
# 1692 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT dir_remove (
 DIR* dp
)
{
 FRESULT res;

 UINT i;

 i = dp->index;
 res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);
 if (res == FR_OK) {
  do {
   res = move_window(dp->fs, dp->sect);
   if (res != FR_OK) break;
   memset(dp->dir, 0, 32);
   *dp->dir = 0xE5;
   dp->fs->wflag = 1;
   if (dp->index >= i) break;
   res = dir_next(dp, 0);
  } while (res == FR_OK);
  if (res == FR_NO_FILE) res = FR_INT_ERR;
 }
# 1728 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
 return res;
}
# 1739 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
void get_fileinfo (
 DIR* dp,
 FILINFO* fno
)
{
 UINT i;
 TCHAR *p, c;


 p = fno->fname;
 if (dp->sect) {
  BYTE *dir = dp->dir;

  i = 0;
  while (i < 11) {
   c = (TCHAR)dir[i++];
   if (c == ' ') continue;
   if (c == 0x05) c = (TCHAR)0xE5;
   if (i == 9) *p++ = '.';

   if ((((c)>='A')&&((c)<='Z')) && (dir[12] & (i >= 9 ? 0x10 : 0x08)))
    c += 0x20;







   *p++ = c;
  }
  fno->fattrib = dir[11];
  fno->fsize = (DWORD)(((DWORD)*((BYTE*)(dir+28)+3)<<24)|((DWORD)*((BYTE*)(dir+28)+2)<<16)|((WORD)*((BYTE*)(dir+28)+1)<<8)|*(BYTE*)(dir+28));
  fno->fdate = (WORD)(((WORD)*((BYTE*)(dir+24)+1)<<8)|(WORD)*(BYTE*)(dir+24));
  fno->ftime = (WORD)(((WORD)*((BYTE*)(dir+22)+1)<<8)|(WORD)*(BYTE*)(dir+22));
 }
 *p = 0;


 if (fno->lfname) {
  WCHAR w, *lfn;

  i = 0; p = fno->lfname;
  if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {
   lfn = dp->lfn;
   while ((w = *lfn++) != 0) {

    w = ff_convert(w, 0);
    if (!w) { i = 0; break; }
    if (0 && w >= 0x100)
     p[i++] = (TCHAR)(w >> 8);

    if (i >= fno->lfsize - 1) { i = 0; break; }
    p[i++] = (TCHAR)w;
   }
  }
  p[i] = 0;
 }

}
# 1809 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT create_name (
 DIR* dp,
 const TCHAR** path
)
{

 BYTE b, cf;
 WCHAR w, *lfn;
 UINT i, ni, si, di;
 const TCHAR *p;


 for (p = *path; *p == '/' || *p == '\\'; p++) ;
 lfn = dp->lfn;
 si = di = 0;
 for (;;) {
  w = p[si++];
  if (w < ' ' || w == '/' || w == '\\') break;
  if (di >= 255)
   return FR_INVALID_NAME;

  w &= 0xFF;
# 1840 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
  w = ff_convert(w, 1);
  if (!w) return FR_INVALID_NAME;

  if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w))
   return FR_INVALID_NAME;
  lfn[di++] = w;
 }
 *path = &p[si];
 cf = (w < ' ') ? 0x04 : 0;
# 1859 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
 while (di) {
  w = lfn[di-1];
  if (w != ' ' && w != '.') break;
  di--;
 }
 if (!di) return FR_INVALID_NAME;

 lfn[di] = 0;


 memset(dp->fn, ' ', 11);
 for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;
 if (si) cf |= 0x01 | 0x02;
 while (di && lfn[di - 1] != '.') di--;

 b = i = 0; ni = 8;
 for (;;) {
  w = lfn[si++];
  if (!w) break;
  if (w == ' ' || (w == '.' && si != di)) {
   cf |= 0x01 | 0x02; continue;
  }

  if (i >= ni || si == di) {
   if (ni == 11) {
    cf |= 0x01 | 0x02; break;
   }
   if (si != di) cf |= 0x01 | 0x02;
   if (si > di) break;
   si = di; i = 8; ni = 11;
   b <<= 2; continue;
  }

  if (w >= 0x80) {

   w = ff_convert(w, 0);
   if (w) w = ExCvt[w - 0x80];



   cf |= 0x02;
  }

  if (0 && w >= 0x100) {
   if (i >= ni - 1) {
    cf |= 0x01 | 0x02; i = ni; continue;
   }
   dp->fn[i++] = (BYTE)(w >> 8);
  } else {
   if (!w || chk_chr("+,;=[]", w)) {
    w = '_'; cf |= 0x01 | 0x02;
   } else {
    if ((((w)>='A')&&((w)<='Z'))) {
     b |= 2;
    } else {
     if ((((w)>='a')&&((w)<='z'))) {
      b |= 1; w -= 0x20;
     }
    }
   }
  }
  dp->fn[i++] = (BYTE)w;
 }

 if (dp->fn[0] == 0xE5) dp->fn[0] = 0x05;

 if (ni == 8) b <<= 2;
 if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)
  cf |= 0x02;
 if (!(cf & 0x02)) {
  if ((b & 0x03) == 0x01) cf |= 0x10;
  if ((b & 0x0C) == 0x04) cf |= 0x08;
 }

 dp->fn[11] = cf;

 return FR_OK;
# 2012 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
}
# 2021 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT follow_path (
 DIR* dp,
 const TCHAR* path
)
{
 FRESULT res;
 BYTE *dir, ns;
# 2038 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
 if (*path == '/' || *path == '\\')
  path++;
 dp->sclust = 0;


 if ((UINT)*path < ' ') {
  res = dir_sdi(dp, 0);
  dp->dir = 0;
 } else {
  for (;;) {
   res = create_name(dp, &path);
   if (res != FR_OK) break;

   res = dir_find(dp);
   ns = dp->fn[11];
   if (res != FR_OK) {
    if (res == FR_NO_FILE) {
     if (0 && (ns & 0x20)) {
      dp->sclust = 0; dp->dir = 0;
      if (!(ns & 0x04)) continue;
      res = FR_OK;
     } else {
      if (!(ns & 0x04)) res = FR_NO_PATH;
     }
    }
    break;
   }
   if (ns & 0x04) break;
   dir = dp->dir;
   if (!(dir[11] & 0x10)) {
    res = FR_NO_PATH; break;
   }
   dp->sclust = ld_clust(dp->fs, dir);
  }
 }

 return res;
}
# 2084 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
int get_ldnumber (
 const TCHAR** path
)
{
 const TCHAR *tp, *tt;
 UINT i;
 int vol = -1;


 if (*path) {
  for (tt = *path; (UINT)*tt >= (1 ? ' ' : '!') && *tt != ':'; tt++) ;
  if (*tt == ':') {
   tp = *path;
   i = *tp++ - '0';
   if (i < 10 && tp == tt) {
    if (i < 1) {
     vol = (int)i;
     *path = ++tt;
    }
   } else {
# 2124 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
   }
   return vol;
  }



  vol = 0;

 }
 return vol;
}
# 2143 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
BYTE check_fs (
 FATFS* fs,
 DWORD sect
)
{
 fs->wflag = 0; fs->winsect = 0xFFFFFFFF;
 if (move_window(fs, sect) != FR_OK)
  return 3;

 if ((WORD)(((WORD)*((BYTE*)(&fs->win[510])+1)<<8)|(WORD)*(BYTE*)(&fs->win[510])) != 0xAA55)
  return 2;

 if (((DWORD)(((DWORD)*((BYTE*)(&fs->win[54])+3)<<24)|((DWORD)*((BYTE*)(&fs->win[54])+2)<<16)|((WORD)*((BYTE*)(&fs->win[54])+1)<<8)|*(BYTE*)(&fs->win[54])) & 0xFFFFFF) == 0x544146)
  return 0;
 if (((DWORD)(((DWORD)*((BYTE*)(&fs->win[82])+3)<<24)|((DWORD)*((BYTE*)(&fs->win[82])+2)<<16)|((WORD)*((BYTE*)(&fs->win[82])+1)<<8)|*(BYTE*)(&fs->win[82])) & 0xFFFFFF) == 0x544146)
  return 0;

 return 1;
}
# 2171 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT find_volume (
 FATFS** rfs,
 const TCHAR** path,
 BYTE wmode
)
{
 BYTE fmt;
 int vol;
 DSTATUS stat;
 DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
 WORD nrsv;
 FATFS *fs;



 *rfs = 0;
 vol = get_ldnumber(path);
 if (vol < 0) return FR_INVALID_DRIVE;


 fs = FatFs[vol];
 if (!fs) return FR_NOT_ENABLED;

 ;
 *rfs = fs;

 if (fs->fs_type) {
  stat = disk_status(fs->drv);
  if (!(stat & 0x01)) {
   if (!0 && wmode && (stat & 0x04))
    return FR_WRITE_PROTECTED;
   return FR_OK;
  }
 }




 fs->fs_type = 0;
 fs->drv = (BYTE)(vol);
 stat = disk_initialize(fs->drv);
 if (stat & 0x01)
  return FR_NOT_READY;
 if (!0 && wmode && (stat & 0x04))
  return FR_WRITE_PROTECTED;





 bsect = 0;
 fmt = check_fs(fs, bsect);
 if (fmt == 1 || (!fmt && (0))) {
  UINT i;
  DWORD br[4];

  for (i = 0; i < 4; i++) {
   BYTE *pt = fs->win+446 + i * 16;
   br[i] = pt[4] ? (DWORD)(((DWORD)*((BYTE*)(&pt[8])+3)<<24)|((DWORD)*((BYTE*)(&pt[8])+2)<<16)|((WORD)*((BYTE*)(&pt[8])+1)<<8)|*(BYTE*)(&pt[8])) : 0;
  }
  i = 0;
  if (i) i--;
  do {
   bsect = br[i];
   fmt = bsect ? check_fs(fs, bsect) : 2;
  } while (!0 && fmt && ++i < 4);
 }
 if (fmt == 3) return FR_DISK_ERR;
 if (fmt) return FR_NO_FILESYSTEM;



 if ((WORD)(((WORD)*((BYTE*)(fs->win+11)+1)<<8)|(WORD)*(BYTE*)(fs->win+11)) != ((UINT)512))
  return FR_NO_FILESYSTEM;

 fasize = (WORD)(((WORD)*((BYTE*)(fs->win+22)+1)<<8)|(WORD)*(BYTE*)(fs->win+22));
 if (!fasize) fasize = (DWORD)(((DWORD)*((BYTE*)(fs->win+36)+3)<<24)|((DWORD)*((BYTE*)(fs->win+36)+2)<<16)|((WORD)*((BYTE*)(fs->win+36)+1)<<8)|*(BYTE*)(fs->win+36));
 fs->fsize = fasize;

 fs->n_fats = fs->win[16];
 if (fs->n_fats != 1 && fs->n_fats != 2)
  return FR_NO_FILESYSTEM;
 fasize *= fs->n_fats;

 fs->csize = fs->win[13];
 if (!fs->csize || (fs->csize & (fs->csize - 1)))
  return FR_NO_FILESYSTEM;

 fs->n_rootdir = (WORD)(((WORD)*((BYTE*)(fs->win+17)+1)<<8)|(WORD)*(BYTE*)(fs->win+17));
 if (fs->n_rootdir % (((UINT)512) / 32))
  return FR_NO_FILESYSTEM;

 tsect = (WORD)(((WORD)*((BYTE*)(fs->win+19)+1)<<8)|(WORD)*(BYTE*)(fs->win+19));
 if (!tsect) tsect = (DWORD)(((DWORD)*((BYTE*)(fs->win+32)+3)<<24)|((DWORD)*((BYTE*)(fs->win+32)+2)<<16)|((WORD)*((BYTE*)(fs->win+32)+1)<<8)|*(BYTE*)(fs->win+32));

 nrsv = (WORD)(((WORD)*((BYTE*)(fs->win+14)+1)<<8)|(WORD)*(BYTE*)(fs->win+14));
 if (!nrsv) return FR_NO_FILESYSTEM;


 sysect = nrsv + fasize + fs->n_rootdir / (((UINT)512) / 32);
 if (tsect < sysect) return FR_NO_FILESYSTEM;
 nclst = (tsect - sysect) / fs->csize;
 if (!nclst) return FR_NO_FILESYSTEM;
 fmt = 1;
 if (nclst >= 4086U) fmt = 2;
 if (nclst >= 65526U) fmt = 3;


 fs->n_fatent = nclst + 2;
 fs->volbase = bsect;
 fs->fatbase = bsect + nrsv;
 fs->database = bsect + sysect;
 if (fmt == 3) {
  if (fs->n_rootdir) return FR_NO_FILESYSTEM;
  fs->dirbase = (DWORD)(((DWORD)*((BYTE*)(fs->win+44)+3)<<24)|((DWORD)*((BYTE*)(fs->win+44)+2)<<16)|((WORD)*((BYTE*)(fs->win+44)+1)<<8)|*(BYTE*)(fs->win+44));
  szbfat = fs->n_fatent * 4;
 } else {
  if (!fs->n_rootdir) return FR_NO_FILESYSTEM;
  fs->dirbase = fs->fatbase + fasize;
  szbfat = (fmt == 2) ?
   fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 }
 if (fs->fsize < (szbfat + (((UINT)512) - 1)) / ((UINT)512))
  return FR_NO_FILESYSTEM;



 fs->last_clust = fs->free_clust = 0xFFFFFFFF;


 fs->fsi_flag = 0x80;

 if (fmt == 3
  && (WORD)(((WORD)*((BYTE*)(fs->win+48)+1)<<8)|(WORD)*(BYTE*)(fs->win+48)) == 1
  && move_window(fs, bsect + 1) == FR_OK)
 {
  fs->fsi_flag = 0;
  if ((WORD)(((WORD)*((BYTE*)(fs->win+510)+1)<<8)|(WORD)*(BYTE*)(fs->win+510)) == 0xAA55
   && (DWORD)(((DWORD)*((BYTE*)(fs->win+0)+3)<<24)|((DWORD)*((BYTE*)(fs->win+0)+2)<<16)|((WORD)*((BYTE*)(fs->win+0)+1)<<8)|*(BYTE*)(fs->win+0)) == 0x41615252
   && (DWORD)(((DWORD)*((BYTE*)(fs->win+484)+3)<<24)|((DWORD)*((BYTE*)(fs->win+484)+2)<<16)|((WORD)*((BYTE*)(fs->win+484)+1)<<8)|*(BYTE*)(fs->win+484)) == 0x61417272)
  {

   fs->free_clust = (DWORD)(((DWORD)*((BYTE*)(fs->win+488)+3)<<24)|((DWORD)*((BYTE*)(fs->win+488)+2)<<16)|((WORD)*((BYTE*)(fs->win+488)+1)<<8)|*(BYTE*)(fs->win+488));


   fs->last_clust = (DWORD)(((DWORD)*((BYTE*)(fs->win+492)+3)<<24)|((DWORD)*((BYTE*)(fs->win+492)+2)<<16)|((WORD)*((BYTE*)(fs->win+492)+1)<<8)|*(BYTE*)(fs->win+492));

  }
 }


 fs->fs_type = fmt;
 fs->id = ++Fsid;







 return FR_OK;
}
# 2342 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
static
FRESULT validate (
 void* obj
)
{
 FIL *fil = (FIL*)obj;


 if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
  return FR_INVALID_OBJECT;

 ;

 if (disk_status(fil->fs->drv) & 0x01)
  return FR_NOT_READY;

 return FR_OK;
}
# 2376 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_mount (
 FATFS* fs,
 const TCHAR* path,
 BYTE opt
)
{
 FATFS *cfs;
 int vol;
 FRESULT res;
 const TCHAR *rp = path;
 BYTE pdrv;

 vol = get_ldnumber(&rp);
 if (vol < 0) return FR_INVALID_DRIVE;
 cfs = FatFs[vol];

 if (cfs) {
  pdrv = (BYTE)(vol);
  if(!fs)
   disk_deinitialize(pdrv);






  cfs->fs_type = 0;
 }

 if (fs) {
  fs->fs_type = 0;



 }
 FatFs[vol] = fs;

 if (!fs || opt != 1) return FR_OK;

 res = find_volume(&fs, &path, 0);
 return res;
}
# 2426 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_open (
 FIL* fp,
 const TCHAR* path,
 BYTE mode
)
{
 FRESULT res;
 DIR dj;
 BYTE *dir;
 BYTE sfn[12];


 if (!fp) return FR_INVALID_OBJECT;
 fp->fs = 0;



 mode &= 0x01 | 0x02 | 0x08 | 0x10 | 0x04;
 res = find_volume(&dj.fs, &path, (BYTE)(mode & ~0x01));




 if (res == FR_OK) {
  { (dj).fn = sfn; (dj).lfn = LfnBuf; };
  res = follow_path(&dj, path);
  dir = dj.dir;

  if (res == FR_OK) {
   if (!dir)
    res = FR_INVALID_NAME;




  }

  if (mode & (0x08 | 0x10 | 0x04)) {
   DWORD dw, cl;

   if (res != FR_OK) {
    if (res == FR_NO_FILE)



     res = dir_register(&dj);

    mode |= 0x08;
    dir = dj.dir;
   }
   else {
    if (dir[11] & (0x01 | 0x10)) {
     res = FR_DENIED;
    } else {
     if (mode & 0x04)
      res = FR_EXIST;
    }
   }
   if (res == FR_OK && (mode & 0x08)) {
    dw = get_fattime();
    *(BYTE*)(dir+14)=(BYTE)(dw); *((BYTE*)(dir+14)+1)=(BYTE)((WORD)(dw)>>8); *((BYTE*)(dir+14)+2)=(BYTE)((DWORD)(dw)>>16); *((BYTE*)(dir+14)+3)=(BYTE)((DWORD)(dw)>>24);
    dir[11] = 0;
    *(BYTE*)(dir+28)=(BYTE)(0); *((BYTE*)(dir+28)+1)=(BYTE)((WORD)(0)>>8); *((BYTE*)(dir+28)+2)=(BYTE)((DWORD)(0)>>16); *((BYTE*)(dir+28)+3)=(BYTE)((DWORD)(0)>>24);
    cl = ld_clust(dj.fs, dir);
    st_clust(dir, 0);
    dj.fs->wflag = 1;
    if (cl) {
     dw = dj.fs->winsect;
     res = remove_chain(dj.fs, cl);
     if (res == FR_OK) {
      dj.fs->last_clust = cl - 1;
      res = move_window(dj.fs, dw);
     }
    }
   }
  }
  else {
   if (res == FR_OK) {
    if (dir[11] & 0x10) {
     res = FR_NO_FILE;
    } else {
     if ((mode & 0x02) && (dir[11] & 0x01))
      res = FR_DENIED;
    }
   }
  }
  if (res == FR_OK) {
   if (mode & 0x08)
    mode |= 0x20;
   fp->dir_sect = dj.fs->winsect;
   fp->dir_ptr = dir;




  }
# 2534 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
  ;

  if (res == FR_OK) {
   fp->flag = mode;
   fp->err = 0;
   fp->sclust = ld_clust(dj.fs, dir);
   fp->fsize = (DWORD)(((DWORD)*((BYTE*)(dir+28)+3)<<24)|((DWORD)*((BYTE*)(dir+28)+2)<<16)|((WORD)*((BYTE*)(dir+28)+1)<<8)|*(BYTE*)(dir+28));
   fp->fptr = 0;
   fp->dsect = 0;



   fp->fs = dj.fs;
   fp->id = fp->fs->id;
  }
 }

 return res;
}
# 2561 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_read (
 FIL* fp,
 void* buff,
 UINT btr,
 UINT* br
)
{
 FRESULT res;
 DWORD clst, sect, remain;
 UINT rcnt, cc;
 BYTE csect, *rbuff = (BYTE*)buff;


 *br = 0;

 res = validate(fp);
 if (res != FR_OK) return res;
 if (fp->err)
  return (FRESULT)fp->err;
 if (!(fp->flag & 0x01))
  return FR_DENIED;
 remain = fp->fsize - fp->fptr;
 if (btr > remain) btr = (UINT)remain;

 for ( ; btr;
  rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  if ((fp->fptr % ((UINT)512)) == 0) {
   csect = (BYTE)(fp->fptr / ((UINT)512) & (fp->fs->csize - 1));
   if (!csect) {
    if (fp->fptr == 0) {
     clst = fp->sclust;
    } else {





      clst = get_fat(fp->fs, fp->clust);
    }
    if (clst < 2) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
    if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
    fp->clust = clst;
   }
   sect = clust2sect(fp->fs, fp->clust);
   if (!sect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
   sect += csect;
   cc = btr / ((UINT)512);
   if (cc) {
    if (csect + cc > fp->fs->csize)
     cc = fp->fs->csize - csect;
    if (disk_read(fp->fs->drv, rbuff, sect, cc))
     { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };





    if ((fp->flag & 0x40) && fp->dsect - sect < cc)
     memcpy(rbuff + ((fp->dsect - sect) * ((UINT)512)), fp->buf, ((UINT)512));


    rcnt = ((UINT)512) * cc;
    continue;
   }

   if (fp->dsect != sect) {

    if (fp->flag & 0x40) {
     if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
      { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
     fp->flag &= ~0x40;
    }

    if (disk_read(fp->fs->drv, fp->buf, sect, 1))
     { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
   }

   fp->dsect = sect;
  }
  rcnt = ((UINT)512) - ((UINT)fp->fptr % ((UINT)512));
  if (rcnt > btr) rcnt = btr;





  memcpy(rbuff, &fp->buf[fp->fptr % ((UINT)512)], rcnt);

 }

 return FR_OK;
}
# 2662 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_write (
 FIL* fp,
 const void *buff,
 UINT btw,
 UINT* bw
)
{
 FRESULT res;
 DWORD clst, sect;
 UINT wcnt, cc;
 const BYTE *wbuff = (const BYTE*)buff;
 BYTE csect;


 *bw = 0;

 res = validate(fp);
 if (res != FR_OK) return res;
 if (fp->err)
  return (FRESULT)fp->err;
 if (!(fp->flag & 0x02))
  return FR_DENIED;
 if (fp->fptr + btw < fp->fptr) btw = 0;

 for ( ; btw;
  wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
  if ((fp->fptr % ((UINT)512)) == 0) {
   csect = (BYTE)(fp->fptr / ((UINT)512) & (fp->fs->csize - 1));
   if (!csect) {
    if (fp->fptr == 0) {
     clst = fp->sclust;
     if (clst == 0)
      clst = create_chain(fp->fs, 0);
    } else {





      clst = create_chain(fp->fs, fp->clust);
    }
    if (clst == 0) break;
    if (clst == 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
    if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
    fp->clust = clst;
    if (fp->sclust == 0) fp->sclust = clst;
   }




   if (fp->flag & 0x40) {
    if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
     { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
    fp->flag &= ~0x40;
   }

   sect = clust2sect(fp->fs, fp->clust);
   if (!sect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
   sect += csect;
   cc = btw / ((UINT)512);
   if (cc) {
    if (csect + cc > fp->fs->csize)
     cc = fp->fs->csize - csect;
    if (disk_write(fp->fs->drv, wbuff, sect, cc))
     { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };







    if (fp->dsect - sect < cc) {
     memcpy(fp->buf, wbuff + ((fp->dsect - sect) * ((UINT)512)), ((UINT)512));
     fp->flag &= ~0x40;
    }


    wcnt = ((UINT)512) * cc;
    continue;
   }






   if (fp->dsect != sect) {
    if (fp->fptr < fp->fsize &&
     disk_read(fp->fs->drv, fp->buf, sect, 1))
      { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
   }

   fp->dsect = sect;
  }
  wcnt = ((UINT)512) - ((UINT)fp->fptr % ((UINT)512));
  if (wcnt > btw) wcnt = btw;






  memcpy(&fp->buf[fp->fptr % ((UINT)512)], wbuff, wcnt);
  fp->flag |= 0x40;

 }

 if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;
 fp->flag |= 0x20;

 return FR_OK;
}
# 2784 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_sync (
 FIL* fp
)
{
 FRESULT res;
 DWORD tm;
 BYTE *dir;


 res = validate(fp);
 if (res == FR_OK) {
  if (fp->flag & 0x20) {


   if (fp->flag & 0x40) {
    if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
     return FR_DISK_ERR;
    fp->flag &= ~0x40;
   }


   res = move_window(fp->fs, fp->dir_sect);
   if (res == FR_OK) {
    dir = fp->dir_ptr;
    dir[11] |= 0x20;
    *(BYTE*)(dir+28)=(BYTE)(fp->fsize); *((BYTE*)(dir+28)+1)=(BYTE)((WORD)(fp->fsize)>>8); *((BYTE*)(dir+28)+2)=(BYTE)((DWORD)(fp->fsize)>>16); *((BYTE*)(dir+28)+3)=(BYTE)((DWORD)(fp->fsize)>>24);
    st_clust(dir, fp->sclust);
    tm = get_fattime();
    *(BYTE*)(dir+22)=(BYTE)(tm); *((BYTE*)(dir+22)+1)=(BYTE)((WORD)(tm)>>8); *((BYTE*)(dir+22)+2)=(BYTE)((DWORD)(tm)>>16); *((BYTE*)(dir+22)+3)=(BYTE)((DWORD)(tm)>>24);
    *(BYTE*)(dir+18)=(BYTE)(0); *((BYTE*)(dir+18)+1)=(BYTE)((WORD)(0)>>8);
    fp->flag &= ~0x20;
    fp->fs->wflag = 1;
    res = sync_fs(fp->fs);
   }
  }
 }

 return res;
}
# 2833 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_close (
 FIL *fp
)
{
 FRESULT res;



 res = f_sync(fp);
 if (res == FR_OK)

 {
  res = validate(fp);
  if (res == FR_OK) {







    fp->fs = 0;



  }
 }
 return res;
}
# 3005 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_lseek (
 FIL* fp,
 DWORD ofs
)
{
 FRESULT res;


 res = validate(fp);
 if (res != FR_OK) return res;
 if (fp->err)
  return (FRESULT)fp->err;
# 3076 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
 {
  DWORD clst, bcs, nsect, ifptr;

  if (ofs > fp->fsize

    && !(fp->flag & 0x02)

   ) ofs = fp->fsize;

  ifptr = fp->fptr;
  fp->fptr = nsect = 0;
  if (ofs) {
   bcs = (DWORD)fp->fs->csize * ((UINT)512);
   if (ifptr > 0 &&
    (ofs - 1) / bcs >= (ifptr - 1) / bcs) {
    fp->fptr = (ifptr - 1) & ~(bcs - 1);
    ofs -= fp->fptr;
    clst = fp->clust;
   } else {
    clst = fp->sclust;

    if (clst == 0) {
     clst = create_chain(fp->fs, 0);
     if (clst == 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
     if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
     fp->sclust = clst;
    }

    fp->clust = clst;
   }
   if (clst != 0) {
    while (ofs > bcs) {

     if (fp->flag & 0x02) {
      clst = create_chain(fp->fs, clst);
      if (clst == 0) {
       ofs = bcs; break;
      }
     } else

      clst = get_fat(fp->fs, clst);
     if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
     if (clst <= 1 || clst >= fp->fs->n_fatent) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
     fp->clust = clst;
     fp->fptr += bcs;
     ofs -= bcs;
    }
    fp->fptr += ofs;
    if (ofs % ((UINT)512)) {
     nsect = clust2sect(fp->fs, clst);
     if (!nsect) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
     nsect += ofs / ((UINT)512);
    }
   }
  }
  if (fp->fptr % ((UINT)512) && nsect != fp->dsect) {


   if (fp->flag & 0x40) {
    if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
     { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
    fp->flag &= ~0x40;
   }

   if (disk_read(fp->fs->drv, fp->buf, nsect, 1))
    { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };

   fp->dsect = nsect;
  }

  if (fp->fptr > fp->fsize) {
   fp->fsize = fp->fptr;
   fp->flag |= 0x20;
  }

 }

 return res;
}
# 3163 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_opendir (
 DIR* dp,
 const TCHAR* path
)
{
 FRESULT res;
 FATFS* fs;
 BYTE sfn[12];


 if (!dp) return FR_INVALID_OBJECT;


 res = find_volume(&fs, &path, 0);
 if (res == FR_OK) {
  dp->fs = fs;
  { (*dp).fn = sfn; (*dp).lfn = LfnBuf; };
  res = follow_path(dp, path);
  ;
  if (res == FR_OK) {
   if (dp->dir) {
    if (dp->dir[11] & 0x10)
     dp->sclust = ld_clust(fs, dp->dir);
    else
     res = FR_NO_PATH;
   }
   if (res == FR_OK) {
    dp->id = fs->id;
    res = dir_sdi(dp, 0);
# 3203 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
   }
  }
  if (res == FR_NO_FILE) res = FR_NO_PATH;
 }
 if (res != FR_OK) dp->fs = 0;

 return res;
}
# 3219 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_closedir (
 DIR *dp
)
{
 FRESULT res;


 res = validate(dp);
 if (res == FR_OK) {
# 3236 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
   dp->fs = 0;



 }
 return res;
}
# 3251 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_readdir (
 DIR* dp,
 FILINFO* fno
)
{
 FRESULT res;
 BYTE sfn[12];


 res = validate(dp);
 if (res == FR_OK) {
  if (!fno) {
   res = dir_sdi(dp, 0);
  } else {
   { (*dp).fn = sfn; (*dp).lfn = LfnBuf; };
   res = dir_read(dp, 0);
   if (res == FR_NO_FILE) {
    dp->sect = 0;
    res = FR_OK;
   }
   if (res == FR_OK) {
    get_fileinfo(dp, fno);
    res = dir_next(dp, 0);
    if (res == FR_NO_FILE) {
     dp->sect = 0;
     res = FR_OK;
    }
   }
   ;
  }
 }

 return res;
}
# 3293 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_stat (
 const TCHAR* path,
 FILINFO* fno
)
{
 FRESULT res;
 DIR dj;
 BYTE sfn[12];



 res = find_volume(&dj.fs, &path, 0);
 if (res == FR_OK) {
  { (dj).fn = sfn; (dj).lfn = LfnBuf; };
  res = follow_path(&dj, path);
  if (res == FR_OK) {
   if (dj.dir) {
    if (fno) get_fileinfo(&dj, fno);
   } else {
    res = FR_INVALID_NAME;
   }
  }
  ;
 }

 return res;
}
# 3328 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_getfree (
 const TCHAR* path,
 DWORD* nclst,
 FATFS** fatfs
)
{
 FRESULT res;
 FATFS *fs;
 DWORD n, clst, sect, stat;
 UINT i;
 BYTE fat, *p;



 res = find_volume(fatfs, &path, 0);
 fs = *fatfs;
 if (res == FR_OK) {

  if (fs->free_clust <= fs->n_fatent - 2) {
   *nclst = fs->free_clust;
  } else {

   fat = fs->fs_type;
   n = 0;
   if (fat == 1) {
    clst = 2;
    do {
     stat = get_fat(fs, clst);
     if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
     if (stat == 1) { res = FR_INT_ERR; break; }
     if (stat == 0) n++;
    } while (++clst < fs->n_fatent);
   } else {
    clst = fs->n_fatent;
    sect = fs->fatbase;
    i = 0; p = 0;
    do {
     if (!i) {
      res = move_window(fs, sect++);
      if (res != FR_OK) break;
      p = fs->win;
      i = ((UINT)512);
     }
     if (fat == 2) {
      if ((WORD)(((WORD)*((BYTE*)(p)+1)<<8)|(WORD)*(BYTE*)(p)) == 0) n++;
      p += 2; i -= 2;
     } else {
      if (((DWORD)(((DWORD)*((BYTE*)(p)+3)<<24)|((DWORD)*((BYTE*)(p)+2)<<16)|((WORD)*((BYTE*)(p)+1)<<8)|*(BYTE*)(p)) & 0x0FFFFFFF) == 0) n++;
      p += 4; i -= 4;
     }
    } while (--clst);
   }
   fs->free_clust = n;
   fs->fsi_flag |= 1;
   *nclst = n;
  }
 }
 return res;
}
# 3395 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_truncate (
 FIL* fp
)
{
 FRESULT res;
 DWORD ncl;


 res = validate(fp);
 if (res == FR_OK) {
  if (fp->err) {
   res = (FRESULT)fp->err;
  } else {
   if (!(fp->flag & 0x02))
    res = FR_DENIED;
  }
 }
 if (res == FR_OK) {
  if (fp->fsize > fp->fptr) {
   fp->fsize = fp->fptr;
   fp->flag |= 0x20;
   if (fp->fptr == 0) {
    res = remove_chain(fp->fs, fp->sclust);
    fp->sclust = 0;
   } else {
    ncl = get_fat(fp->fs, fp->clust);
    res = FR_OK;
    if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
    if (ncl == 1) res = FR_INT_ERR;
    if (res == FR_OK && ncl < fp->fs->n_fatent) {
     res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
     if (res == FR_OK) res = remove_chain(fp->fs, ncl);
    }
   }

   if (res == FR_OK && (fp->flag & 0x40)) {
    if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
     res = FR_DISK_ERR;
    else
     fp->flag &= ~0x40;
   }

  }
  if (res != FR_OK) fp->err = (FRESULT)res;
 }

 return res;
}
# 3451 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_unlink (
 const TCHAR* path
)
{
 FRESULT res;
 DIR dj, sdj;
 BYTE *dir;
 DWORD dclst;
 BYTE sfn[12];



 res = find_volume(&dj.fs, &path, 1);
 if (res == FR_OK) {
  { (dj).fn = sfn; (dj).lfn = LfnBuf; };
  res = follow_path(&dj, path);
  if (0 && res == FR_OK && (dj.fn[11] & 0x20))
   res = FR_INVALID_NAME;



  if (res == FR_OK) {
   dir = dj.dir;
   if (!dir) {
    res = FR_INVALID_NAME;
   } else {
    if (dir[11] & 0x01)
     res = FR_DENIED;
   }
   dclst = ld_clust(dj.fs, dir);
   if (res == FR_OK && (dir[11] & 0x10)) {
    if (dclst < 2) {
     res = FR_INT_ERR;
    } else {
     memcpy(&sdj, &dj, sizeof (DIR));
     sdj.sclust = dclst;
     res = dir_sdi(&sdj, 2);
     if (res == FR_OK) {
      res = dir_read(&sdj, 0);
      if (res == FR_OK



      ) res = FR_DENIED;
      if (res == FR_NO_FILE) res = FR_OK;
     }
    }
   }
   if (res == FR_OK) {
    res = dir_remove(&dj);
    if (res == FR_OK) {
     if (dclst)
      res = remove_chain(dj.fs, dclst);
     if (res == FR_OK) res = sync_fs(dj.fs);
    }
   }
  }
  ;
 }

 return res;
}
# 3521 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_mkdir (
 const TCHAR* path
)
{
 FRESULT res;
 DIR dj;
 BYTE *dir, n;
 DWORD dsc, dcl, pcl, tm = get_fattime();
 BYTE sfn[12];



 res = find_volume(&dj.fs, &path, 1);
 if (res == FR_OK) {
  { (dj).fn = sfn; (dj).lfn = LfnBuf; };
  res = follow_path(&dj, path);
  if (res == FR_OK) res = FR_EXIST;
  if (0 && res == FR_NO_FILE && (dj.fn[11] & 0x20))
   res = FR_INVALID_NAME;
  if (res == FR_NO_FILE) {
   dcl = create_chain(dj.fs, 0);
   res = FR_OK;
   if (dcl == 0) res = FR_DENIED;
   if (dcl == 1) res = FR_INT_ERR;
   if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   if (res == FR_OK)
    res = sync_window(dj.fs);
   if (res == FR_OK) {
    dsc = clust2sect(dj.fs, dcl);
    dir = dj.fs->win;
    memset(dir, 0, ((UINT)512));
    memset(dir+0, ' ', 11);
    dir[0] = '.';
    dir[11] = 0x10;
    *(BYTE*)(dir+22)=(BYTE)(tm); *((BYTE*)(dir+22)+1)=(BYTE)((WORD)(tm)>>8); *((BYTE*)(dir+22)+2)=(BYTE)((DWORD)(tm)>>16); *((BYTE*)(dir+22)+3)=(BYTE)((DWORD)(tm)>>24);
    st_clust(dir, dcl);
    memcpy(dir+32, dir, 32);
    dir[32 +1] = '.'; pcl = dj.sclust;
    if (dj.fs->fs_type == 3 && pcl == dj.fs->dirbase)
     pcl = 0;
    st_clust(dir+32, pcl);
    for (n = dj.fs->csize; n; n--) {
     dj.fs->winsect = dsc++;
     dj.fs->wflag = 1;
     res = sync_window(dj.fs);
     if (res != FR_OK) break;
     memset(dir, 0, ((UINT)512));
    }
   }
   if (res == FR_OK) res = dir_register(&dj);
   if (res != FR_OK) {
    remove_chain(dj.fs, dcl);
   } else {
    dir = dj.dir;
    dir[11] = 0x10;
    *(BYTE*)(dir+22)=(BYTE)(tm); *((BYTE*)(dir+22)+1)=(BYTE)((WORD)(tm)>>8); *((BYTE*)(dir+22)+2)=(BYTE)((DWORD)(tm)>>16); *((BYTE*)(dir+22)+3)=(BYTE)((DWORD)(tm)>>24);
    st_clust(dir, dcl);
    dj.fs->wflag = 1;
    res = sync_fs(dj.fs);
   }
  }
  ;
 }

 return res;
}
# 3595 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_chmod (
 const TCHAR* path,
 BYTE value,
 BYTE mask
)
{
 FRESULT res;
 DIR dj;
 BYTE *dir;
 BYTE sfn[12];



 res = find_volume(&dj.fs, &path, 1);
 if (res == FR_OK) {
  { (dj).fn = sfn; (dj).lfn = LfnBuf; };
  res = follow_path(&dj, path);
  ;
  if (0 && res == FR_OK && (dj.fn[11] & 0x20))
   res = FR_INVALID_NAME;
  if (res == FR_OK) {
   dir = dj.dir;
   if (!dir) {
    res = FR_INVALID_NAME;
   } else {
    mask &= 0x01|0x02|0x04|0x20;
    dir[11] = (value & mask) | (dir[11] & (BYTE)~mask);
    dj.fs->wflag = 1;
    res = sync_fs(dj.fs);
   }
  }
 }

 return res;
}
# 3638 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_utime (
 const TCHAR* path,
 const FILINFO* fno
)
{
 FRESULT res;
 DIR dj;
 BYTE *dir;
 BYTE sfn[12];



 res = find_volume(&dj.fs, &path, 1);
 if (res == FR_OK) {
  { (dj).fn = sfn; (dj).lfn = LfnBuf; };
  res = follow_path(&dj, path);
  ;
  if (0 && res == FR_OK && (dj.fn[11] & 0x20))
   res = FR_INVALID_NAME;
  if (res == FR_OK) {
   dir = dj.dir;
   if (!dir) {
    res = FR_INVALID_NAME;
   } else {
    *(BYTE*)(dir+22)=(BYTE)(fno->ftime); *((BYTE*)(dir+22)+1)=(BYTE)((WORD)(fno->ftime)>>8);
    *(BYTE*)(dir+24)=(BYTE)(fno->fdate); *((BYTE*)(dir+24)+1)=(BYTE)((WORD)(fno->fdate)>>8);
    dj.fs->wflag = 1;
    res = sync_fs(dj.fs);
   }
  }
 }

 return res;
}
# 3680 "../../../component/common/file_system/fatfs/r0.10c/src/ff.c"
FRESULT f_rename (
 const TCHAR* path_old,
 const TCHAR* path_new
)
{
 FRESULT res;
 DIR djo, djn;
 BYTE buf[21], *dir;
 DWORD dw;
 BYTE sfn[12];



 res = find_volume(&djo.fs, &path_old, 1);
 if (res == FR_OK) {
  djn.fs = djo.fs;
  { (djo).fn = sfn; (djo).lfn = LfnBuf; };
  res = follow_path(&djo, path_old);
  if (0 && res == FR_OK && (djo.fn[11] & 0x20))
   res = FR_INVALID_NAME;



  if (res == FR_OK) {
   if (!djo.dir) {
    res = FR_NO_FILE;
   } else {
    memcpy(buf, djo.dir+11, 21);
    memcpy(&djn, &djo, sizeof (DIR));
    if (get_ldnumber(&path_new) >= 0)
     res = follow_path(&djn, path_new);
    else
     res = FR_INVALID_DRIVE;
    if (res == FR_OK) res = FR_EXIST;
    if (res == FR_NO_FILE) {

     res = dir_register(&djn);
     if (res == FR_OK) {
      dir = djn.dir;
      memcpy(dir+13, buf+2, 19);
      dir[11] = buf[0] | 0x20;
      djo.fs->wflag = 1;
      if (djo.sclust != djn.sclust && (dir[11] & 0x10)) {
       dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
       if (!dw) {
        res = FR_INT_ERR;
       } else {
        res = move_window(djo.fs, dw);
        dir = djo.fs->win+32;
        if (res == FR_OK && dir[1] == '.') {
         dw = (djo.fs->fs_type == 3 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
         st_clust(dir, dw);
         djo.fs->wflag = 1;
        }
       }
      }
      if (res == FR_OK) {
       res = dir_remove(&djo);
       if (res == FR_OK)
        res = sync_fs(djo.fs);
      }
     }

    }
   }
  }
  ;
 }

 return res;
}
